---
title: Understanding Promise Chaining
date: "2025-07-25"
description: "I thought I know Promise, until I started writing a polyfill for it. And I am not alone. :D"
keywords: "Promise, Polyfill, Chaining"
featured: true
---

Let's be honest, nobody needs to write a polyfill for promise these days. Most of us only look for it when we
start preparing for interviews. Promise polyfill is among the most common questions asked in JavaScript interviews.
As a consequence, there are endless blogs on this.

So why am I writing this? 

Well I found that most of them have implemented Promise wrong! Most common mistake that I find in these implementations is that they `return this`.
However, if you go through [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise),
it clearly state that [`then` returns a **new Promise**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#return_value).

So, in this post, I want to take you through my journey on what I feel is the correct implementation of promise.

## Defining Promise

Let's start by defining a basic Promise class.

```TypeScript
type ExecutorFn<T> = (
  resolve: (data?: T) => any,
  reject: (reason?: any) => any,
) => void;

class MyPromise<T> {
  constructor(executor: ExecutorFn) {}

  /**
   * Called when Promise is resolved.
   */
  private resolve = (data?: T) => {}

  /**
   * Called when Promise is rejected
   */
  private reject = (error?: any) => {}
}
```

This seems simple enough to start. We have a constructor for our Promise which takes executor function as
parameter. This executor function will be passed resolve and reject callbacks to fulfill or reject the promise respectively.
We have two private methods for resolve and reject as well.

Before we start Implementing these methods, we must define how the Promise works. Let's list down the key behaviors:
1. **Executor function should be run synchronously when the Promise is created.**<br/>
One of the most common mistake I see calling the executor function inside `setTimeout`. When in reality the executor
function is ran as soon as Promise is created. This can be verified by running following snippet in browser console.
```JavaScript
console.log('Start');
const p = new Promise((resolve) => {
  console.log('Executor Function Called');
  resolve('Promise Resolved');
});
p.then((value) => console.log(value));
console.log('End');

/** Result: **
Start
Executor Function Called
End
Promise Resolved
*/
```
2. **`resolve` and `reject` should be pushed to micro task queue.**<br/>
Another common mistake is using `setTimeout`. Promises are pushed to micro task queue where as
`setTimeout` goes to macro task queue (or just task queue). I have seen few people describing this
behavior as Promise having a higher priority. If this is something new to you and you want to understand
this better, [I suggest you watch this awesome talk](https://www.youtube.com/watch?v=cCOL7MC4Pl0).
3. **`then`, `catch` and `finally` should return a new Promise.**
4. **Multiple `then`, `catch` and `finally` can be added to same promise.**<br/>
Though Promise can be resolved/rejected only once. We can attach multiple `then`, `catch`, `finally` blocks to it.
5. **`then`, `catch` and `finally` can be called on a Promise, long after the Promise has been fulfilled/Rejected.**<br/>
We can verify above 2 points using following code snippet.
```JavaScript
const p = Promise.resolve('Data');

p.then((value) => console.log('Get 1:', value));
p.then((value) => console.log('Get 2:', value));

setTimeout(() => {
  p.then((value) => console.log('Get 3:', value))
}, 5000);

/** Result: **
Get 1: Data
Get 2: Data
// After 5 seconds
Get 3: Data
*/
```
6. **If callbacks from `then`, `catch` and `finally` returns a promise then the returned Promise should be chained.**<br/>
This means that we can even return a Promise from callbacks passed to `then`, `catch` and `finally` and still receive
the resolved value of the returned Promise. Following snippet will demonstrate this.
```JavaScript
const p = Promise.reject('Bad Request');
p.then(() => console.log('What?'))
 .catch(() => Promise.resolve('Handled'))
 .then((value) => console.log(value));
/** Result: **
Handled

** Explanation **
Here the first `then` is never called and `catch` block
returns a Promise. But the value received by second `then`
block is not Promise but the resolved value of the returned
Promise.
*/
```
7. **Unhandled rejection should be caught and logged in browser console.**
8. **`finally` should be called in both resolution and rejection of the promise.**

Now we can implement our constructor

```TypeScript{3-9}
class MyPromise<T> {
  constructor(executor: ExecutorFn) {
    // Call the executor synchronously [1]
    try {
      executor(this.resolve, this.reject);
    } catch (e) {
      // Reject promise on error
      this.reject(e);
    }
  }

  /**
   * Called when Promise is resolved.
   */
  private resolve = (data?: T) => {}

  /**
   * Called when Promise is rejected
   */
  private reject = (error?: any) => {}
}
```

## Resolve and Reject

Next Let's implement the resolve and reject function. For this we need do define few variables in our class.
Since a Promise can be only one of the three state (`Pending`, `Fulfilled`, or `Rejected`) we need a `status` variable.
And since we know that Promise value can be used long after it has settled, we should also store the value.
For this I am creating 2 variables, `successData` and `failureError`.

```TypeScript {2-7}
class MyPromise<T> {
  /** Status of the Promise */
  private status: 'pending' | 'fulfilled' | 'rejected' = 'pending';
  /** Stores value of the promise if it is resolved */
  private successData?: T;
  /** Stores error returned by the promise if it is rejected */
  private failureError?: any;

  constructor(executor: ExecutorFn) {
    // Call the executor synchronously [1]
    try {
      executor(this.resolve, this.reject);
    } catch (e) {
      // Reject promise on error
      this.reject(e);
    }
  }

  /**
   * Called when Promise is resolved.
   */
  private resolve = (data?: T) => {}

  /**
   * Called when Promise is rejected
   */
  private reject = (error?: any) => {}
}
```

Now Let's focus on resolve. As we know, we need to push the execution of resolve
in a micro task queue, we will have to use `queueMicrotask` function. Inside this, we will
have to update the status to `fulfilled` and also save the value passed to resolve function.
It is also a good idea to check that Promise is in `pending` state, so that we don't override
the value if resolve is called twice. Thus we can write our resolve function as described below:

```TypeScript{23-30}
class MyPromise<T> {
  /** Status of the Promise */
  private status: 'pending' | 'fulfilled' | 'rejected' = 'pending';
  /** Stores value of the promise if it is resolved */
  private successData?: T;
  /** Stores error returned by the promise if it is rejected */
  private failureError?: any;

  constructor(executor: ExecutorFn) {
    // Call the executor synchronously [1]
    try {
      executor(this.resolve, this.reject);
    } catch (e) {
      // Reject promise on error
      this.reject(e);
    }
  }

  /**
   * Called when Promise is resolved.
   */
  private resolve = (data?: T) => {
    queueMicrotask(() => {
      // Promise can be resolved only once
      if (this.status === 'pending') {
        // Update status and store data
        this.status = 'fulfilled';
        this.successData = data;
      }
    });
  }

  /**
   * Called when Promise is rejected
   */
  private reject = (error?: any) => {}
}
```

Similarly implementing reject as:

```TypeScript{37-44}
class MyPromise<T> {
  /** Status of the Promise */
  private status: 'pending' | 'fulfilled' | 'rejected' = 'pending';
  /** Stores value of the promise if it is resolved */
  private successData?: T;
  /** Stores error returned by the promise if it is rejected */
  private failureError?: any;

  constructor(executor: ExecutorFn) {
    // Call the executor synchronously [1]
    try {
      executor(this.resolve, this.reject);
    } catch (e) {
      // Reject promise on error
      this.reject(e);
    }
  }

  /**
   * Called when Promise is resolved.
   */
  private resolve = (data?: T) => {
    queueMicrotask(() => {
      // Promise can be resolved only once
      if (this.status === 'pending') {
        // Update status and store data
        this.status = 'fulfilled';
        this.successData = data;
      }
    });
  }

  /**
   * Called when Promise is rejected
   */
  private reject = (error?: any) => {
    queueMicrotask(() => {
      // Promise can be rejected only once
      if (this.status === 'pending') {
        // Update status and store error
        this.status = 'rejected';
        this.failureError = error;
      }
    });
  }
}
```


## Implementing `then`

The main challenge in implementing Promise Polyfill lies in `then`. Rest can be easily implemented using this then function.


### Basic implementation

### Complete implementation

## Implementing `catch` and `finally`

## Static methods in Promise

## Full implementation

## Conclusion


